<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QI(b,t) = e^(-Σ) — Boltzmann Energy Landscape</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #08090e; overflow: hidden; font-family: 'Courier New', monospace; color: #aab; }
  canvas { display: block; }

  /* ── GUIDED TOUR ── */
  #tour-scrim {
    position: fixed; inset: 0; background: rgba(4,5,10,0.55); z-index: 90;
    transition: opacity 0.4s; pointer-events: none;
  }
  #tour-scrim.hidden { opacity: 0; }
  #tour {
    position: fixed; z-index: 100; left: 24px; top: 50%; transform: translateY(-50%);
    width: 340px; background: rgba(10,12,20,0.96); border: 1px solid #1e2540;
    border-radius: 8px; padding: 0; overflow: hidden;
    box-shadow: 0 8px 40px rgba(0,0,0,0.6); transition: opacity 0.3s, transform 0.3s;
  }
  #tour.hidden { opacity: 0; pointer-events: none; transform: translateY(-50%) translateX(-20px); }
  #tour-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 16px; background: rgba(20,24,40,0.8); border-bottom: 1px solid #1a2030;
  }
  #tour-progress { display: flex; gap: 4px; }
  #tour-progress .dot {
    width: 8px; height: 8px; border-radius: 50%; background: #1a2030;
    transition: background 0.3s, transform 0.2s;
  }
  #tour-progress .dot.active { background: #6ad; transform: scale(1.3); }
  #tour-progress .dot.done { background: #4a7; }
  #tour-skip { background: none; border: none; color: #445; font-size: 10px; font-family: inherit; cursor: pointer; padding: 2px 6px; }
  #tour-skip:hover { color: #8bf; }
  #tour-step { color: #556; font-size: 9px; letter-spacing: 1px; }
  #tour-body { padding: 20px 20px 16px; line-height: 1.65; font-size: 12.5px; min-height: 140px; }
  #tour-body h2 { color: #8bf; font-size: 15px; font-weight: normal; margin: 0 0 10px; }
  #tour-body .eq { color: #6ad; font-family: 'Courier New', monospace; background: #0a0c14; padding: 8px 12px; display: block; margin: 8px 0; border-left: 2px solid #234; font-size: 12px; line-height: 1.8; }
  #tour-body .term { color: #8bf; }
  #tour-body .dim { color: #445; }
  #tour-body .key { color: #6a8; }
  #tour-body p { margin: 6px 0; }
  #tour-body ul { padding-left: 18px; margin: 6px 0; }
  #tour-body li { margin: 3px 0; }
  #tour-nav {
    display: flex; gap: 8px; padding: 0 20px 16px; justify-content: flex-end;
  }
  #tour-nav button {
    padding: 8px 20px; font-family: inherit; font-size: 12px; border-radius: 4px; cursor: pointer; border: 1px solid #2a3060;
  }
  #tour-back { background: transparent; color: #556; border-color: #1a2030; }
  #tour-back:hover { color: #8bf; border-color: #2a3060; }
  #tour-back:disabled { opacity: 0.3; cursor: default; }
  #tour-next { background: #1a2848; color: #8bf; }
  #tour-next:hover { background: #2a3868; }
  #tour-reopen {
    position: fixed; left: 12px; top: 12px; z-index: 60; background: #141828;
    border: 1px solid #1a2030; color: #445; font-family: inherit; font-size: 10px;
    padding: 5px 10px; cursor: pointer; border-radius: 3px; display: none;
  }
  #tour-reopen:hover { color: #8bf; border-color: #2a3060; }

  /* ── SIDEBAR CONTROLS ── */
  #sidebar {
    position: fixed; right: 0; top: 0; width: 220px; height: 100%; background: rgba(8,10,16,0.95);
    border-left: 1px solid #151820; z-index: 50; padding: 14px; overflow-y: auto;
    transform: translateX(220px); transition: transform 0.3s;
  }
  #sidebar.open { transform: translateX(0); }
  #sidebar h3 { color: #556; font-size: 10px; margin: 12px 0 6px; letter-spacing: 1px; font-weight: normal; }
  #sidebar label { display: flex; align-items: center; gap: 6px; font-size: 10px; color: #667; margin: 4px 0; }
  #sidebar input[type=range] { flex: 1; accent-color: #4488aa; height: 14px; }
  #sidebar .val-display { color: #8bf; min-width: 28px; text-align: right; font-size: 10px; }
  #sidebar button {
    display: block; width: 100%; padding: 7px 0; margin: 4px 0; background: #141828;
    border: 1px solid #1a2030; color: #889; font-family: inherit; font-size: 10px;
    cursor: pointer; border-radius: 2px;
  }
  #sidebar button:hover { background: #1e2540; color: #aab; }
  #sidebar button.active { border-color: #4488aa; color: #8bf; background: #1a2848; }
  #sidebar button.attack { border-color: #a44; }
  #sidebar button.attack:hover { background: #2a1520; color: #f88; }

  #toggle-sidebar {
    position: fixed; right: 8px; top: 8px; z-index: 60; background: #141828;
    border: 1px solid #1a2030; color: #556; font-family: inherit; font-size: 11px;
    padding: 5px 10px; cursor: pointer; border-radius: 2px;
  }
  #toggle-sidebar:hover { color: #8bf; }

  /* ── TOOLTIP ── */
  #tooltip {
    position: fixed; pointer-events: none; z-index: 80; background: rgba(10,12,20,0.95);
    border: 1px solid #1a2030; padding: 8px 12px; font-size: 10px; line-height: 1.6;
    border-radius: 3px; display: none; max-width: 280px;
  }
  #tooltip .tt-band { color: #8bf; font-size: 11px; }
  #tooltip .tt-val { color: #6ad; }
  #tooltip .tt-dim { color: #445; }

  /* ── I₀ DETECTION LOG ── */
  #i0-log {
    position: fixed; left: 12px; bottom: 44px; z-index: 40;
    width: 260px; max-height: 120px; overflow-y: auto; font-size: 9px;
    background: rgba(8,10,16,0.9); border: 1px solid #1a2030; border-radius: 3px;
    padding: 6px 8px; display: none;
  }
  #i0-log.visible { display: block; }
  #i0-log .log-entry { margin: 2px 0; }
  #i0-log .log-warn { color: #cc8; }
  #i0-log .log-crit { color: #e66; }
  #i0-log .log-block { color: #f44; font-weight: bold; }
  #i0-log .log-clear { color: #4c8; }
  #i0-log .log-ts { color: #334; }

  /* ── I₀ STATUS BADGE ── */
  #i0-status {
    position: fixed; left: 12px; bottom: 168px; z-index: 40;
    font-size: 10px; padding: 6px 10px; border-radius: 3px;
    background: rgba(8,10,16,0.9); border: 1px solid #1a2030;
    display: none; line-height: 1.5;
  }
  #i0-status.visible { display: block; }
  #i0-status .status-label { color: #556; }
  #i0-status .status-normal { color: #4c8; }
  #i0-status .status-warning { color: #cc8; }
  #i0-status .status-critical { color: #f66; }
  #i0-status .status-blocking { color: #f33; animation: pulse-red 0.6s infinite alternate; }
  @keyframes pulse-red { from { opacity: 0.7; } to { opacity: 1; } }

  #controls {
    position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%);
    color: #334; font-size: 11px; text-align: center; pointer-events: none; z-index: 10;
  }
</style>
</head>
<body>

<!-- GUIDED TOUR -->
<div id="tour-scrim"></div>
<div id="tour">
  <div id="tour-header">
    <span id="tour-step">STEP 1 / 6</span>
    <div id="tour-progress"></div>
    <button id="tour-skip">Skip tour</button>
  </div>
  <div id="tour-body"></div>
  <div id="tour-nav">
    <button id="tour-back" disabled>Back</button>
    <button id="tour-next">Next</button>
  </div>
</div>
<button id="tour-reopen">? Guide</button>

<!-- SIDEBAR -->
<button id="toggle-sidebar">Controls</button>
<div id="sidebar">
  <h3>CLASSICAL WEIGHTS (Σ<sub>c</sub>)</h3>
  <label>w<sub>1</sub> σ²φ <input type="range" min="0" max="3" step="0.1" value="1" data-key="w1"> <span class="val-display">1.0</span></label>
  <label>w<sub>2</sub> Hτ <input type="range" min="0" max="3" step="0.1" value="1" data-key="w2"> <span class="val-display">1.0</span></label>
  <label>w<sub>3</sub> σ²γ <input type="range" min="0" max="3" step="0.1" value="1" data-key="w3"> <span class="val-display">1.0</span></label>
  <label>w<sub>4</sub> Dsf <input type="range" min="0" max="3" step="0.1" value="1" data-key="w4"> <span class="val-display">1.0</span></label>

  <h3>QUANTUM WEIGHTS (Σ<sub>q</sub>)</h3>
  <label>ψ<sub>1</sub> Q̂i <input type="range" min="0" max="3" step="0.1" value="1" data-key="p1"> <span class="val-display">1.0</span></label>
  <label>ψ<sub>2</sub> Q̂t <input type="range" min="0" max="3" step="0.1" value="1" data-key="p2"> <span class="val-display">1.0</span></label>
  <label>ψ<sub>3</sub> Q̂e <input type="range" min="0" max="3" step="0.1" value="1" data-key="p3"> <span class="val-display">1.0</span></label>

  <h3>SIMULATION</h3>
  <label>Speed <input type="range" min="0.1" max="5" step="0.1" value="1" id="speed-slider"> <span class="val-display" id="speed-val">1.0</span></label>
  <button id="btn-tunnel" class="active">Tunneling: ON</button>
  <button id="btn-decohere">Decoherence Pulse</button>

  <h3>I₀ DETECTION SYSTEM</h3>
  <button id="btn-shield" class="active">Shield: ON</button>
  <button id="btn-shield-log">Detection Log</button>
  <label>Threshold <input type="range" min="0.1" max="0.9" step="0.05" value="0.3" id="threshold-slider"> <span class="val-display" id="threshold-val">0.30</span></label>

  <h3>ATTACK SCENARIOS</h3>
  <button class="attack" id="atk-classical">Classical Injection<br><span class="dim" style="font-size:9px">Spike σ²φ + σ²γ on all bands</span></button>
  <button class="attack" id="atk-quantum">Quantum Exploit<br><span class="dim" style="font-size:9px">Spike Q̂i, suppress Q̂e</span></button>
  <button class="attack" id="atk-tunnel">Tunneling Flood<br><span class="dim" style="font-size:9px">Max Q̂t at I₀ boundary</span></button>
  <button class="attack" id="atk-reset">Reset to Normal</button>

  <h3>INFO</h3>
  <button id="btn-info">Show Explainer</button>
</div>

<!-- I₀ DETECTION SYSTEM -->
<div id="i0-status"></div>
<div id="i0-log"></div>

<!-- TOOLTIP -->
<div id="tooltip"></div>

<canvas id="c"></canvas>
<div id="controls">
  [space] decoherence &nbsp; [hover] inspect &nbsp; [click] select band &nbsp; [?] guide &nbsp; [tab] sidebar
</div>

<script>
const C = document.getElementById('c');
const ctx = C.getContext('2d');
const tooltip = document.getElementById('tooltip');

// ── BANDS (v4.0: 7-1-3 Hourglass) ──

const BANDS = [
  { id: 'N7', name: 'Neocortex',         zone: 'neural',    desc: 'Highest cognitive functions, language, planning' },
  { id: 'N6', name: 'Limbic',            zone: 'neural',    desc: 'Emotion, memory, hippocampus, amygdala' },
  { id: 'N5', name: 'Basal Ganglia',     zone: 'neural',    desc: 'Motor control, habit learning, reward' },
  { id: 'N4', name: 'Diencephalon',      zone: 'neural',    desc: 'Thalamic relay, hypothalamic regulation' },
  { id: 'N3', name: 'Cerebellum',        zone: 'neural',    desc: 'Motor coordination, timing, prediction' },
  { id: 'N2', name: 'Brainstem',         zone: 'neural',    desc: 'Vital functions, arousal, cranial nerves' },
  { id: 'N1', name: 'Spinal Cord',       zone: 'neural',    desc: 'Reflex arcs, peripheral motor/sensory' },
  { id: 'I0', name: 'Neural Interface',  zone: 'interface', desc: 'Electrode-tissue boundary. Measurement collapse.' },
  { id: 'S1', name: 'Analog Front-End',  zone: 'synthetic',   desc: 'Amplification, filtering, ADC/DAC' },
  { id: 'S2', name: 'Digital Processing', zone: 'synthetic',  desc: 'Decoding algorithms, classification' },
  { id: 'S3', name: 'Application',       zone: 'synthetic',   desc: 'Clinical software, UI, data storage' },
];
const NB = BANDS.length;
const N_CH = 1024;

// ── EQUATION ──

const w = { w1: 1, w2: 1, w3: 1, w4: 1 };
const psi = { p1: 1, p2: 1, p3: 1 };
let decoherencePulse = false, pulseStart = 0;
let tunnelingActive = true;

// Attack state — additive overrides
const attackBoost = { sigma_phi: 0, sigma_gamma: 0, qi_boost: 0, qe_suppress: 0, qt_boost: 0 };

// ── I₀ DETECTION & BLOCKING ──
let i0Shield = true;
let i0BlockThreshold = 0.3;
let i0WarnThreshold = 0.6;
let i0Status = 'normal'; // 'normal', 'warning', 'critical', 'blocking'
let i0GateAnim = 0; // 0 = open, 1 = fully closed
let i0BlockStart = 0;
let i0SignalArrows = []; // propagation arrows
const blockLog = [];
const MAX_LOG = 40;
let lastLogStatus = 'normal';
let logVisible = false;

function gamma_D(t) {
  let gd = 0.4 + 0.15 * Math.sin(t * 0.3);
  if (decoherencePulse) {
    const el = t - pulseStart;
    if (el > 4) decoherencePulse = false;
    else gd = Math.min(1, gd + 0.55 * Math.exp(-el * 1.2) * (1 + Math.sin(el * 15)));
  }
  return Math.max(0, Math.min(1, gd));
}

function sigma2_phi(t, i) { return 0.2 + 0.15 * Math.sin(t * 0.7 + i * 0.8) + 0.05 * Math.sin(t * 2.1 + i * 1.3) + attackBoost.sigma_phi; }
function H_tau(t, i) { return (2.5 + 1.5 * Math.sin(t * 0.4 + i * 0.6)) / Math.log(N_CH); }
function sigma2_gamma(t, i) { return 0.15 + 0.1 * Math.sin(t * 0.5 + i * 1.1) + 0.03 * Math.sin(t * 3.2 + i * 0.5) + attackBoost.sigma_gamma; }
function D_sf(t, i) { const d = 0.1 * Math.sin(t * 0.6 + i * 0.9); return d * d; }
function Q_i(t, i) { return BANDS[i].zone === 'synthetic' ? 0 : 0.3 + 0.2 * Math.sin(t * 0.8 + i * 0.7) + attackBoost.qi_boost; }
function Q_t(t, i) {
  if (!tunnelingActive) return 0;
  const base = 0.15 * Math.exp(-Math.abs(i - 7) * 0.4) * (0.6 + 0.4 * Math.sin(t * 1.5 + i * 2));
  return base + (i >= 6 && i <= 8 ? attackBoost.qt_boost : 0);
}
function Q_e(t, i) { return BANDS[i].zone === 'synthetic' ? 0 : Math.max(0, 0.2 + 0.15 * Math.sin(t * 0.6 + i * 1.2) - attackBoost.qe_suppress); }

function Sigma_c(t, i) { return w.w1 * sigma2_phi(t, i) + w.w2 * H_tau(t, i) + w.w3 * sigma2_gamma(t, i) + w.w4 * D_sf(t, i); }
function Sigma_q(t, i) {
  const gd = gamma_D(t);
  return (1 - gd) * (psi.p1 * Q_i(t, i) - psi.p3 * Q_e(t, i)) + psi.p2 * Q_t(t, i);
}
function Sigma_(t, i) { return Sigma_c(t, i) + Sigma_q(t, i); }

function QI_raw(t, i) { return Math.exp(-Math.max(0, Sigma_(t, i))); }

function QI(t, i) {
  const raw = QI_raw(t, i);
  // When shield is active and I₀ is blocking, synthetic bands get cleaned
  if (i0Shield && i >= 8 && i0GateAnim > 0.3) {
    // Gate attenuates anomalous energy on synthetic side
    // The more closed the gate, the more synthetic bands are protected
    const protection = i0GateAnim; // 0..1
    // Blend toward clean signal (QI→0.85) proportional to gate closure
    return raw + (0.85 - raw) * protection * 0.9;
  }
  return raw;
}

// I₀ detection update — called each frame
function updateI0Detection(t) {
  const qi_i0 = QI_raw(t, 7); // raw I₀ QI (band index 7)
  let newStatus;

  if (!i0Shield) {
    newStatus = 'normal';
    i0GateAnim *= 0.95; // relax gate
  } else if (qi_i0 < i0BlockThreshold) {
    newStatus = 'blocking';
    i0GateAnim = Math.min(1, i0GateAnim + 0.08);
  } else if (qi_i0 < i0WarnThreshold) {
    newStatus = 'warning';
    i0GateAnim = Math.min(0.5, i0GateAnim + 0.03);
    if (i0GateAnim > 0.5) i0GateAnim *= 0.97;
  } else {
    newStatus = 'normal';
    i0GateAnim *= 0.93;
  }

  // Log status transitions
  if (newStatus !== lastLogStatus) {
    const ts = time.toFixed(1);
    if (newStatus === 'warning' && lastLogStatus === 'normal')
      addLogEntry(ts, 'warn', `Anomaly detected at I\u2080 \u2014 QI=${qi_i0.toFixed(3)}`);
    else if (newStatus === 'blocking')
      addLogEntry(ts, 'block', `SIGNAL BLOCKED at I\u2080 \u2014 QI=${qi_i0.toFixed(3)} < ${i0BlockThreshold.toFixed(2)}`);
    else if (newStatus === 'normal' && lastLogStatus !== 'normal')
      addLogEntry(ts, 'clear', `I\u2080 returned to normal \u2014 QI=${qi_i0.toFixed(3)}`);
    else if (newStatus === 'warning' && lastLogStatus === 'blocking')
      addLogEntry(ts, 'warn', `Block released, still elevated \u2014 QI=${qi_i0.toFixed(3)}`);
    lastLogStatus = newStatus;
  }

  i0Status = newStatus;

  // Update status badge
  const badge = document.getElementById('i0-status');
  if (i0Shield) {
    badge.classList.add('visible');
    const qi_str = qi_i0.toFixed(3);
    const gate_str = (i0GateAnim * 100).toFixed(0);
    const cls = i0Status === 'blocking' ? 'status-blocking' : i0Status === 'warning' ? 'status-warning' : 'status-normal';
    badge.innerHTML = `<span class="status-label">I\u2080 SHIELD</span><br>` +
      `<span class="${cls}">${i0Status.toUpperCase()}</span><br>` +
      `QI(I\u2080) = <span class="${cls}">${qi_str}</span><br>` +
      `Gate: <span class="${cls}">${gate_str}%</span>`;
  } else {
    badge.classList.remove('visible');
  }

  // Spawn signal arrows periodically
  if (frame % 8 === 0) {
    i0SignalArrows.push({ y: 0, blocked: false, age: 0 });
  }
}

function addLogEntry(ts, type, msg) {
  const cls = type === 'block' ? 'log-block' : type === 'warn' ? 'log-warn' : type === 'crit' ? 'log-crit' : 'log-clear';
  blockLog.unshift({ ts, cls, msg });
  if (blockLog.length > MAX_LOG) blockLog.pop();
  renderLog();
}

function renderLog() {
  const el = document.getElementById('i0-log');
  el.innerHTML = blockLog.map(e =>
    `<div class="log-entry"><span class="log-ts">[t=${e.ts}]</span> <span class="${e.cls}">${e.msg}</span></div>`
  ).join('');
}

function hourglassWidth(i) {
  if (i === 7) return 0.3;
  return 0.3 + Math.abs(i - 7) * 0.1;
}

// ── STATE ──

let time = 0, speed = 1.0, selectedBand = 7, hoveredBand = -1;
const HISTORY_LEN = 200;
const history = Array.from({ length: NB }, () => ({ qi: [], sc: [], sq: [] }));
const particles = Array.from({ length: NB }, () => ({ x: 0, vy: 0, tunnelFlash: 0 }));

// ── LAYOUT ──

let W, H;
function resize() {
  W = innerWidth; H = innerHeight;
  C.width = W * devicePixelRatio; C.height = H * devicePixelRatio;
  C.style.width = W + 'px'; C.style.height = H + 'px';
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}
resize();
addEventListener('resize', resize);

function panels() {
  const sb = document.getElementById('sidebar').classList.contains('open') ? 220 : 0;
  const aw = W - sb;
  const pad = 16;
  return {
    A: { x: pad, y: pad + 20, w: aw * 0.52 - pad * 2, h: H - pad * 2 - 60 },
    B: { x: aw * 0.55, y: pad + 20, w: aw * 0.44 - pad, h: H * 0.42 },
    C: { x: aw * 0.55, y: H * 0.47 + pad, w: aw * 0.21 - pad / 2, h: H * 0.50 - pad * 2 },
    D: { x: aw * 0.77, y: H * 0.47 + pad, w: aw * 0.22 - pad, h: H * 0.50 - pad * 2 },
  };
}

// ── COLORS ──

function qiColor(qi, a = 1) {
  if (qi > 0.6) { const t = (qi - 0.6) / 0.4; return `rgba(${20 | 0},${140 + t * 80 | 0},${200 + t * 55 | 0},${a})`; }
  if (qi > 0.3) { const t = (qi - 0.3) / 0.3; return `rgba(${200 - t * 160 | 0},${t * 180 + 80 | 0},${40 + t * 100 | 0},${a})`; }
  const t = qi / 0.3; return `rgba(${180 + (1 - t) * 40 | 0},${40 + t * 40 | 0},30,${a})`;
}
function zoneColor(i, a = 1) {
  if (BANDS[i].zone === 'neural') return `rgba(200,160,60,${a})`;
  if (BANDS[i].zone === 'interface') return `rgba(200,200,255,${a})`;
  return `rgba(60,120,200,${a})`;
}

// ── PANEL A: HOURGLASS ──

function drawHourglass(t, p) {
  ctx.save();
  ctx.beginPath(); ctx.rect(p.x, p.y, p.w, p.h); ctx.clip();
  const bandH = p.h / NB;
  const centerX = p.x + p.w * 0.45;

  ctx.fillStyle = '#445'; ctx.font = '10px Courier New';
  ctx.fillText('BOLTZMANN ENERGY LANDSCAPE', p.x, p.y - 6);

  for (let i = 0; i < NB; i++) {
    const y = p.y + i * bandH;
    const qi = QI(t, i), sig = Sigma_(t, i), sc = Sigma_c(t, i), sq = Sigma_q(t, i);
    const hw = hourglassWidth(i) * p.w, qt = Q_t(t, i);
    const left = centerX - hw, right = centerX + hw;
    const isHov = i === hoveredBand, isSel = i === selectedBand;

    ctx.fillStyle = qiColor(qi, isHov ? 0.35 : 0.2);
    ctx.fillRect(left, y + 1, hw * 2, bandH - 2);
    ctx.strokeStyle = isSel ? '#fff' : isHov ? '#8bf' : zoneColor(i, 0.4);
    ctx.lineWidth = isSel ? 1.5 : isHov ? 1 : 0.5;
    ctx.strokeRect(left, y + 1, hw * 2, bandH - 2);

    // Energy bars
    const scBarW = Math.min(sc / 2, 1) * p.w * 0.35;
    ctx.fillStyle = 'rgba(100,180,220,0.5)';
    ctx.fillRect(right + 8, y + 3, scBarW, bandH * 0.4 - 2);
    const sqBarW = Math.min(Math.abs(sq) / 0.5, 1) * p.w * 0.15;
    ctx.fillStyle = sq > 0 ? 'rgba(200,80,200,0.5)' : 'rgba(80,200,140,0.4)';
    ctx.fillRect(right + 8 + scBarW, y + 3, sqBarW * Math.sign(sq), bandH * 0.4 - 2);

    // Particle
    const part = particles[i];
    const targetX = (sig - 0.7) * 60;
    part.vy += (targetX - part.x) * 0.08;
    part.vy *= 0.85;
    const gd = gamma_D(t);
    if (gd > 0.5) part.vy += (Math.random() - 0.5) * gd * 4;
    part.x += part.vy;
    if (tunnelingActive && qt > 0.1 && Math.random() < qt * 0.03) { part.x += (Math.random() - 0.5) * 80; part.tunnelFlash = 1; }
    part.tunnelFlash *= 0.9;

    const px = centerX + Math.max(-hw + 4, Math.min(hw - 4, part.x));
    const py = y + bandH * 0.5, pr = 3 + qi * 3;

    const glow = ctx.createRadialGradient(px, py, 0, px, py, pr * 4);
    glow.addColorStop(0, qiColor(qi, 0.4 + part.tunnelFlash * 0.4));
    glow.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glow;
    ctx.beginPath(); ctx.arc(px, py, pr * 4, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = part.tunnelFlash > 0.1 ? `rgba(200,80,255,${0.8 + part.tunnelFlash * 0.2})` : qiColor(qi, 0.9);
    ctx.beginPath(); ctx.arc(px, py, pr, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = isSel ? '#dde' : isHov ? '#aab' : '#556';
    ctx.font = `${isSel ? 'bold ' : ''}10px Courier New`;
    ctx.fillText(BANDS[i].id, p.x + 2, y + bandH * 0.5 + 3);

    ctx.fillStyle = qiColor(qi, 0.8); ctx.font = '9px Courier New';
    ctx.fillText(`QI=${qi.toFixed(3)}`, left - 58, y + bandH * 0.35 + 3);
    ctx.fillStyle = '#445';
    ctx.fillText(`\u03A3=${sig.toFixed(2)}`, left - 58, y + bandH * 0.75 + 3);

    if (i === 0) { ctx.fillStyle = '#554'; ctx.font = '9px Courier New'; ctx.fillText('NEURAL', p.x + p.w - 46, y + 10); }
    if (i === 7) { ctx.fillStyle = '#668'; ctx.font = '9px Courier New'; ctx.fillText('I\u2080', p.x + p.w - 16, y + bandH * 0.6); }
    if (i === 8) { ctx.fillStyle = '#458'; ctx.font = '9px Courier New'; ctx.fillText('SILICON', p.x + p.w - 50, y + 10); }
  }

  // Potential curve
  ctx.beginPath(); ctx.strokeStyle = 'rgba(200,220,255,0.5)'; ctx.lineWidth = 1.5;
  for (let i = 0; i < NB; i++) {
    const y = p.y + i * bandH + bandH * 0.5, x = centerX + Sigma_(t, i) * 50;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // ── I₀ GATE VISUALIZATION ──
  if (i0Shield) {
    const gateY = p.y + 7 * bandH + bandH; // between I₀ and S1
    const gateHW = hourglassWidth(7) * p.w;
    const gateLeft = centerX - gateHW;
    const gateRight = centerX + gateHW;
    const gateThickness = 2 + i0GateAnim * 8;

    // Gate bar — grows thicker as it closes
    const gateAlpha = 0.3 + i0GateAnim * 0.7;
    const gateColor = i0Status === 'blocking' ? `rgba(255,50,50,${gateAlpha})` :
                       i0Status === 'warning' ? `rgba(220,180,50,${gateAlpha})` :
                       `rgba(50,200,100,${gateAlpha * 0.5})`;
    ctx.fillStyle = gateColor;
    ctx.fillRect(gateLeft, gateY - gateThickness / 2, gateHW * 2, gateThickness);

    // Gate glow
    if (i0GateAnim > 0.2) {
      const glowGrad = ctx.createLinearGradient(gateLeft, gateY - 20, gateLeft, gateY + 20);
      glowGrad.addColorStop(0, 'rgba(0,0,0,0)');
      glowGrad.addColorStop(0.5, i0Status === 'blocking' ? `rgba(255,40,40,${i0GateAnim * 0.3})` : `rgba(220,180,40,${i0GateAnim * 0.15})`);
      glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glowGrad;
      ctx.fillRect(gateLeft - 10, gateY - 20, gateHW * 2 + 20, 40);
    }

    // Chevron pattern on gate when blocking
    if (i0Status === 'blocking') {
      ctx.strokeStyle = `rgba(255,100,100,${0.3 + 0.3 * Math.sin(t * 6)})`;
      ctx.lineWidth = 1;
      const chevCount = 5;
      for (let c = 0; c < chevCount; c++) {
        const cx = gateLeft + (c + 0.5) * (gateHW * 2 / chevCount);
        ctx.beginPath();
        ctx.moveTo(cx - 4, gateY - 3); ctx.lineTo(cx, gateY + 3); ctx.lineTo(cx + 4, gateY - 3);
        ctx.stroke();
      }
    }

    // Signal flow arrows (neural → I₀ → synthetic)
    for (let a = i0SignalArrows.length - 1; a >= 0; a--) {
      const arrow = i0SignalArrows[a];
      arrow.y += 1.2; // move downward (N7 → S3)
      arrow.age++;

      const arrowBandIndex = arrow.y / bandH;
      const arrowScreenY = p.y + arrow.y;

      // Check if arrow hits the gate
      if (!arrow.blocked && arrowBandIndex >= 7.8 && i0GateAnim > 0.4) {
        arrow.blocked = true;
        arrow.blockY = arrowScreenY;
      }

      if (arrowScreenY > p.y + p.h || arrow.age > 200) {
        i0SignalArrows.splice(a, 1);
        continue;
      }

      const ax = centerX + (Math.sin(arrow.age * 0.15) * 8);

      if (arrow.blocked) {
        // Reflected signal — bounces back up from gate
        const reflect = (arrow.age - (arrow.blockY - p.y) / 1.2) * 0.8;
        const ry = arrow.blockY - reflect;
        if (ry < p.y) { i0SignalArrows.splice(a, 1); continue; }

        // Reflection spark
        ctx.fillStyle = `rgba(255,80,80,${Math.max(0, 0.6 - reflect * 0.02)})`;
        ctx.beginPath(); ctx.arc(ax, ry, 2, 0, Math.PI * 2); ctx.fill();

        // Block impact flash
        if (reflect < 10) {
          ctx.fillStyle = `rgba(255,60,60,${0.5 - reflect * 0.05})`;
          ctx.beginPath(); ctx.arc(ax, arrow.blockY, 4 + reflect * 0.3, 0, Math.PI * 2); ctx.fill();
        }
      } else {
        // Normal propagating signal
        const bandAt = Math.floor(arrowBandIndex);
        const qi = bandAt >= 0 && bandAt < NB ? QI(t, bandAt) : 0.8;
        ctx.fillStyle = qiColor(qi, 0.6);
        ctx.beginPath(); ctx.arc(ax, arrowScreenY, 1.5, 0, Math.PI * 2); ctx.fill();
      }
    }

    // Gate label
    if (i0GateAnim > 0.1) {
      ctx.fillStyle = i0Status === 'blocking' ? '#f55' : i0Status === 'warning' ? '#cc8' : '#4a6';
      ctx.font = '8px Courier New';
      ctx.fillText(i0Status === 'blocking' ? 'BLOCKED' : i0Status === 'warning' ? 'ATTENUATING' : 'PASS',
        gateRight + 6, gateY + 3);
      ctx.fillStyle = '#334';
      ctx.fillText(`gate ${(i0GateAnim * 100).toFixed(0)}%`, gateRight + 6, gateY + 13);
    }

    // I₀ detection ring
    const i0Y = p.y + 7 * bandH + bandH * 0.5;
    const ringR = 16 + Math.sin(t * 3) * 2;
    const ringColor = i0Status === 'blocking' ? `rgba(255,50,50,${0.5 + 0.3 * Math.sin(t * 8)})` :
                      i0Status === 'warning' ? `rgba(220,180,50,${0.4 + 0.2 * Math.sin(t * 4)})` :
                      `rgba(50,200,100,${0.2})`;
    ctx.strokeStyle = ringColor;
    ctx.lineWidth = i0Status === 'blocking' ? 2.5 : 1.5;
    ctx.beginPath(); ctx.arc(centerX, i0Y, ringR, 0, Math.PI * 2); ctx.stroke();
    if (i0Status !== 'normal') {
      ctx.beginPath(); ctx.arc(centerX, i0Y, ringR + 6, 0, Math.PI * 2);
      ctx.strokeStyle = ringColor.replace(/[\d.]+\)$/, '0.15)'); ctx.lineWidth = 1; ctx.stroke();
    }
  }

  // ── TOUR HIGHLIGHTS ──
  if (tourHighlightBand === 'hourglass') {
    // Pulsing outline on the full hourglass shape
    const pulse = 0.4 + 0.3 * Math.sin(t * 3);
    ctx.strokeStyle = `rgba(100,170,220,${pulse})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < NB; i++) {
      const hw = hourglassWidth(i) * p.w;
      const y1 = p.y + i * bandH + 1;
      if (i === 0) ctx.moveTo(centerX + hw, y1);
      else ctx.lineTo(centerX + hourglassWidth(i) * p.w, y1);
    }
    for (let i = NB - 1; i >= 0; i--) {
      const hw = hourglassWidth(i) * p.w;
      const y1 = p.y + i * bandH + bandH - 1;
      ctx.lineTo(centerX - hw, y1);
    }
    ctx.closePath(); ctx.stroke();
    // Width annotations
    ctx.fillStyle = `rgba(100,170,220,${pulse})`;
    ctx.font = '9px Courier New';
    const topHW = hourglassWidth(0) * p.w;
    const midHW = hourglassWidth(7) * p.w;
    ctx.fillText('\u2190 wide: more indeterministic \u2192', centerX - topHW - 2, p.y + bandH * 0.3);
    ctx.fillText('\u2190 narrow \u2192', centerX - midHW + 4, p.y + 7 * bandH + bandH * 0.3);
  }
  if (tourHighlightBand === 'i0') {
    // Pulsing highlight on I₀ band
    const pulse = 0.3 + 0.4 * Math.sin(t * 4);
    const y7 = p.y + 7 * bandH;
    const hw7 = hourglassWidth(7) * p.w;
    ctx.strokeStyle = `rgba(200,200,255,${pulse})`;
    ctx.lineWidth = 2.5;
    ctx.strokeRect(centerX - hw7 - 2, y7 - 1, hw7 * 2 + 4, bandH + 2);
    ctx.fillStyle = `rgba(200,200,255,${pulse * 0.15})`;
    ctx.fillRect(centerX - hw7 - 2, y7 - 1, hw7 * 2 + 4, bandH + 2);
  }

  ctx.fillStyle = '#334'; ctx.font = '9px Courier New';
  ctx.fillText('\u03A3(b) \u2192 potential height  |  QI = e^(-\u03A3) \u2192 occupation probability', p.x, p.y + p.h + 14);
  ctx.restore();
}

// ── PANEL B: SPECTROGRAM ──

const spectroData = [];
const SPECTRO_COLS = 200;

function drawSpectrogram(t, p) {
  ctx.save();
  ctx.fillStyle = '#445'; ctx.font = '10px Courier New';
  ctx.fillText('SPECTROGRAM  QI(b,t)  \u2014 time \u2192', p.x, p.y - 6);

  const col = [];
  for (let i = 0; i < NB; i++) col.push(QI(t, i));
  spectroData.push(col);
  if (spectroData.length > SPECTRO_COLS) spectroData.shift();

  const cellW = p.w / SPECTRO_COLS, cellH = p.h / NB;
  for (let c = 0; c < spectroData.length; c++) {
    for (let r = 0; r < NB; r++) {
      ctx.fillStyle = qiColor(spectroData[c][r], 0.85);
      ctx.fillRect(p.x + c * cellW, p.y + r * cellH, cellW + 0.5, cellH + 0.5);
    }
  }

  for (let i = 0; i < NB; i++) {
    ctx.fillStyle = i === selectedBand ? '#aab' : '#334';
    ctx.font = '8px Courier New'; ctx.textAlign = 'right';
    ctx.fillText(BANDS[i].id, p.x - 3, p.y + i * cellH + cellH * 0.7);
  }
  ctx.textAlign = 'left';
  ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(p.x, p.y, p.w, p.h);

  // Legend
  const legY = p.y + p.h + 12;
  ctx.fillStyle = '#334'; ctx.font = '8px Courier New'; ctx.fillText('QI:', p.x, legY);
  for (let i = 0; i < 50; i++) { ctx.fillStyle = qiColor(i / 50); ctx.fillRect(p.x + 20 + i * 3, legY - 8, 3, 8); }
  ctx.fillStyle = '#445';
  ctx.fillText('0', p.x + 20, legY + 10); ctx.fillText('1', p.x + 168, legY + 10);
  ctx.fillText('red=anomalous  blue=healthy', p.x + 190, legY);
  ctx.restore();
}

// ── PANEL C: PHASE PORTRAIT ──

const phaseHistory = Array.from({ length: NB }, () => []);
const PHASE_LEN = 150;

function drawPhasePortrait(t, p) {
  ctx.save();
  const i = selectedBand, sc = Sigma_c(t, i), sq = Sigma_q(t, i);
  phaseHistory[i].push({ sc, sq });
  if (phaseHistory[i].length > PHASE_LEN) phaseHistory[i].shift();

  ctx.fillStyle = '#445'; ctx.font = '10px Courier New';
  ctx.fillText(`PHASE PORTRAIT  ${BANDS[i].id}`, p.x, p.y - 6);

  const ox = p.x + p.w * 0.5, oy = p.y + p.h * 0.5;
  const scaleX = p.w * 0.35, scaleY = p.h * 0.8;

  ctx.strokeStyle = '#1a1d28'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(p.x + 4, oy); ctx.lineTo(p.x + p.w - 4, oy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(ox, p.y + 4); ctx.lineTo(ox, p.y + p.h - 4); ctx.stroke();

  ctx.fillStyle = '#335'; ctx.font = '8px Courier New';
  ctx.fillText('\u03A3c \u2192', p.x + p.w - 26, oy - 4);
  ctx.fillText('\u03A3q', ox + 4, p.y + 12);

  ctx.strokeStyle = 'rgba(80,200,100,0.15)'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.arc(ox, oy, 0.3 * scaleX, 0, Math.PI * 2); ctx.stroke();
  ctx.strokeStyle = 'rgba(200,180,60,0.15)';
  ctx.beginPath(); ctx.arc(ox, oy, 0.7 * scaleX, 0, Math.PI * 2); ctx.stroke();

  const pts = phaseHistory[i];
  if (pts.length > 1) {
    ctx.beginPath();
    for (let j = 0; j < pts.length; j++) {
      const px = ox + (pts[j].sc - 0.7) * scaleX, py = oy - pts[j].sq * scaleY;
      if (j === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.strokeStyle = zoneColor(i, 0.5); ctx.lineWidth = 1; ctx.stroke();
  }

  const cx = ox + (sc - 0.7) * scaleX, cy = oy - sq * scaleY, qi = QI(t, i);
  const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, 12);
  grad.addColorStop(0, qiColor(qi, 0.6)); grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, 12, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = qiColor(qi, 1); ctx.beginPath(); ctx.arc(cx, cy, 3, 0, Math.PI * 2); ctx.fill();

  ctx.fillStyle = '#556'; ctx.font = '9px Courier New';
  ctx.fillText(`\u03A3c=${sc.toFixed(3)}  \u03A3q=${sq.toFixed(3)}`, p.x + 4, p.y + p.h - 16);
  ctx.fillText(`QI=${qi.toFixed(4)}  \u0393D=${gamma_D(t).toFixed(3)}`, p.x + 4, p.y + p.h - 4);
  ctx.strokeStyle = '#1a1d28'; ctx.lineWidth = 1; ctx.strokeRect(p.x, p.y, p.w, p.h);
  ctx.restore();
}

// ── PANEL D: WAVEFORM ──

function drawWaveform(t, p) {
  ctx.save();
  ctx.fillStyle = '#445'; ctx.font = '10px Courier New';
  ctx.fillText('QI(t) WAVEFORM \u2014 all bands', p.x, p.y - 6);
  ctx.fillStyle = '#0c0d14'; ctx.fillRect(p.x, p.y, p.w, p.h);

  const y06 = p.y + p.h * 0.4, y03 = p.y + p.h * 0.7;
  ctx.strokeStyle = 'rgba(80,200,100,0.15)'; ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(p.x, y06); ctx.lineTo(p.x + p.w, y06); ctx.stroke();
  ctx.fillStyle = '#2a3'; ctx.font = '7px Courier New'; ctx.fillText('0.6', p.x + p.w - 18, y06 - 2);
  ctx.strokeStyle = 'rgba(200,180,60,0.15)';
  ctx.beginPath(); ctx.moveTo(p.x, y03); ctx.lineTo(p.x + p.w, y03); ctx.stroke();
  ctx.fillStyle = '#a83'; ctx.fillText('0.3', p.x + p.w - 18, y03 - 2);

  for (let i = 0; i < NB; i++) {
    const hist = history[i].qi;
    if (hist.length < 2) continue;
    const isSel = i === selectedBand;
    ctx.beginPath();
    ctx.strokeStyle = isSel ? qiColor(QI(t, i), 0.9) : zoneColor(i, 0.15);
    ctx.lineWidth = isSel ? 1.5 : 0.5;
    for (let j = 0; j < hist.length; j++) {
      const x = p.x + (j / HISTORY_LEN) * p.w, y = p.y + p.h * (1 - hist[j]);
      if (j === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  const qi = QI(t, selectedBand);
  ctx.fillStyle = qiColor(qi, 0.9);
  ctx.beginPath(); ctx.arc(p.x + p.w - 2, p.y + p.h * (1 - qi), 3, 0, Math.PI * 2); ctx.fill();

  ctx.fillStyle = '#445'; ctx.font = '9px Courier New';
  ctx.fillText(`${BANDS[selectedBand].id}: QI = e^(-\u03A3) = e^(-(${Sigma_c(t, selectedBand).toFixed(2)} + ${Sigma_q(t, selectedBand).toFixed(2)})) = ${qi.toFixed(4)}`, p.x + 4, p.y + p.h + 14);
  ctx.strokeStyle = '#1a1d28'; ctx.lineWidth = 1; ctx.strokeRect(p.x, p.y, p.w, p.h);
  ctx.restore();
}

// ── EQUATION BAR ──

function drawEquation(t) {
  const i = selectedBand, qi = QI(t, i), sc = Sigma_c(t, i), sq = Sigma_q(t, i);
  const shieldStr = i0Shield ? `I\u2080 Shield: ${i0Status.toUpperCase()} (gate ${(i0GateAnim * 100).toFixed(0)}%)` : 'I\u2080 Shield: OFF';
  ctx.fillStyle = '#334'; ctx.font = '11px Courier New';
  ctx.fillText(
    `QI(${BANDS[i].id}, t) = e^(-\u03A3)  |  \u03A3 = ${sc.toFixed(3)} + ${sq.toFixed(3)} = ${(sc + sq).toFixed(3)}  |  QI = ${qi.toFixed(4)}  |  \u0393D = ${gamma_D(t).toFixed(3)}  |  ${shieldStr}`,
    16, H - 26
  );
}

// ── MAIN LOOP ──

let lastTs = 0, frame = 0;
function tick(ts) {
  requestAnimationFrame(tick);
  const dt = Math.min((ts - lastTs) / 1000, 0.05) * speed;
  lastTs = ts; time += dt; frame++;

  for (let i = 0; i < NB; i++) {
    history[i].qi.push(QI(time, i));
    history[i].sc.push(Sigma_c(time, i));
    history[i].sq.push(Sigma_q(time, i));
    if (history[i].qi.length > HISTORY_LEN) { history[i].qi.shift(); history[i].sc.shift(); history[i].sq.shift(); }
  }

  // Decay attack boosts
  attackBoost.sigma_phi *= 0.998; attackBoost.sigma_gamma *= 0.998;
  attackBoost.qi_boost *= 0.998; attackBoost.qe_suppress *= 0.998;
  attackBoost.qt_boost *= 0.998;

  // I₀ detection system
  updateI0Detection(time);

  ctx.fillStyle = '#08090e'; ctx.fillRect(0, 0, W, H);
  const P = panels();
  drawHourglass(time, P.A);
  if (frame % 2 === 0) drawSpectrogram(time, P.B);
  drawPhasePortrait(time, P.C);
  drawWaveform(time, P.D);
  drawEquation(time);
}
requestAnimationFrame(tick);

// ── TOOLTIP ON HOVER ──

let mouseX = 0, mouseY = 0;
addEventListener('mousemove', (e) => {
  mouseX = e.clientX; mouseY = e.clientY;
  const P = panels();
  const A = P.A;
  if (mouseX >= A.x && mouseX <= A.x + A.w && mouseY >= A.y && mouseY <= A.y + A.h) {
    const bandH = A.h / NB;
    const i = Math.floor((mouseY - A.y) / bandH);
    if (i >= 0 && i < NB) {
      hoveredBand = i;
      const b = BANDS[i];
      const qi = QI(time, i), sc = Sigma_c(time, i), sq = Sigma_q(time, i);
      const sp = sigma2_phi(time, i), ht = H_tau(time, i), sg = sigma2_gamma(time, i), ds = D_sf(time, i);
      const qii = Q_i(time, i), qtt = Q_t(time, i), qee = Q_e(time, i);
      tooltip.innerHTML = `
        <div class="tt-band">${b.id} ${b.name}</div>
        <div class="tt-dim">${b.desc}</div>
        <hr style="border:0;border-top:1px solid #1a2030;margin:4px 0">
        <div><span class="tt-dim">QI =</span> <span class="tt-val">${qi.toFixed(4)}</span> <span class="tt-dim">= e^(-${(sc + sq).toFixed(3)})</span></div>
        <div class="tt-dim" style="margin-top:4px">\u03A3c = ${sc.toFixed(3)}</div>
        <div class="tt-dim">&nbsp; w\u2081\u00B7\u03C3\u00B2\u03C6 = ${(w.w1 * sp).toFixed(3)} <span style="color:#335">(phase)</span></div>
        <div class="tt-dim">&nbsp; w\u2082\u00B7H\u03C4 = ${(w.w2 * ht).toFixed(3)} <span style="color:#335">(transport)</span></div>
        <div class="tt-dim">&nbsp; w\u2083\u00B7\u03C3\u00B2\u03B3 = ${(w.w3 * sg).toFixed(3)} <span style="color:#335">(amplitude)</span></div>
        <div class="tt-dim">&nbsp; w\u2084\u00B7D<sub>sf</sub> = ${(w.w4 * ds).toFixed(3)} <span style="color:#335">(scale-freq)</span></div>
        <div class="tt-dim" style="margin-top:4px">\u03A3q = ${sq.toFixed(3)}</div>
        <div class="tt-dim">&nbsp; Q\u0302i = ${qii.toFixed(3)} <span style="color:#335">(indeterminacy)</span></div>
        <div class="tt-dim">&nbsp; Q\u0302t = ${qtt.toFixed(3)} <span style="color:#335">(tunneling, ungated)</span></div>
        <div class="tt-dim">&nbsp; Q\u0302e = ${qee.toFixed(3)} <span style="color:#335">(entanglement, protective)</span></div>
        <div class="tt-dim">&nbsp; \u0393D = ${gamma_D(time).toFixed(3)} <span style="color:#335">(decoherence)</span></div>
      `;
      tooltip.style.display = 'block';
      tooltip.style.left = Math.min(mouseX + 16, W - 300) + 'px';
      tooltip.style.top = Math.min(mouseY - 10, H - 280) + 'px';
      return;
    }
  }
  hoveredBand = -1;
  tooltip.style.display = 'none';
});

// ── CLICK TO SELECT ──

addEventListener('click', (e) => {
  if (e.target.closest('#sidebar') || e.target.closest('#toggle-sidebar') || e.target.closest('#tour') || e.target.closest('#tour-reopen')) return;
  const P = panels();
  const A = P.A;
  if (mouseX >= A.x && mouseX <= A.x + A.w) {
    const bandH = A.h / NB;
    const i = Math.floor((mouseY - A.y) / bandH);
    if (i >= 0 && i < NB) selectedBand = i;
  }
});

// ── KEYBOARD ──

addEventListener('keydown', (e) => {
  if (e.code === 'Space') { e.preventDefault(); decoherencePulse = true; pulseStart = time; }
  if (e.key === 't') { tunnelingActive = !tunnelingActive; document.getElementById('btn-tunnel').textContent = `Tunneling: ${tunnelingActive ? 'ON' : 'OFF'}`; document.getElementById('btn-tunnel').classList.toggle('active', tunnelingActive); }
  if (e.key === 'Tab') { e.preventDefault(); document.getElementById('sidebar').classList.toggle('open'); }
  if (e.key === '=' || e.key === '+') speed = Math.min(5, speed + 0.5);
  if (e.key === '-') speed = Math.max(0.1, speed - 0.5);
  if (e.key === 'ArrowRight' && !tourEl.classList.contains('hidden')) tourNext();
  if (e.key === 'ArrowLeft' && !tourEl.classList.contains('hidden')) tourBack();
  if (e.key === 'Escape' && !tourEl.classList.contains('hidden')) tourClose();
  if (e.key === '?' || e.key === 'g') { if (tourEl.classList.contains('hidden')) tourOpen(); }
});

// ══════════════════════════════════════════════════
// ── GUIDED TOUR ENGINE ──
// ══════════════════════════════════════════════════

const TOUR_STEPS = [
  {
    title: 'What is QI?',
    body: `
      <p><span class="term">QI</span> stands for <strong>Quantum Indeterminism</strong> — a scale from 0 to 1 that measures how confident we are a neural signal is legitimate.</p>
      <p>Think of it as a <strong>trust score</strong> for brain-computer interfaces.</p>
      <ul>
        <li><span class="key">QI = 1.0</span> — Signal is fully trustworthy</li>
        <li><span class="key">QI = 0.6</span> — Warning threshold</li>
        <li><span class="key">QI = 0.0</span> — Completely anomalous</li>
      </ul>
      <p class="dim">The "quantum" part: neural signals have inherent indeterminacy that increases at higher layers of the brain. This isn't noise — it's a fundamental property we can measure and use for security.</p>
    `,
    highlight: null,
  },
  {
    title: 'The Hourglass',
    body: `
      <p>The 11 bands form an <strong>hourglass</strong> — wide at the top, narrow at the middle, wide again at the bottom.</p>
      <p>Look at the left panel. Notice how each band has a different width:</p>
      <ul>
        <li><span class="key">N7 Neocortex</span> (top) — <strong>widest</strong>. Highest cognitive functions. The most indeterministic — billions of possible neural states. Largest attack surface.</li>
        <li><span class="key">N1 Spinal Cord</span> — narrower. Simpler reflexes, fewer states.</li>
        <li><span class="key">I\u2080 Interface</span> (middle) — <strong>narrowest</strong>. The physical electrode-tissue boundary. Only what's measurable passes through.</li>
        <li><span class="key">S3 Application</span> (bottom) — wide again. Classical software, deterministic but complex.</li>
      </ul>
      <p><strong>Width = state space = attack surface.</strong> The wider the band, the more ways an attacker can hide an anomalous signal in legitimate-looking neural activity.</p>
    `,
    highlight: 'hourglass',
  },
  {
    title: 'Synthetic Bands',
    body: `
      <p>The 3 synthetic bands below I\u2080 are organized by <strong>electromagnetic physics regime</strong> — not by OSI protocol layers.</p>
      <ul>
        <li><span class="key">S1 Analog Front-End</span> — Near-field (0–10 kHz). Amplifiers, filters, ADC/DAC. Attacks: side-channel leakage, impedance manipulation.</li>
        <li><span class="key">S2 Digital Processing</span> — Guided-wave (10 kHz–1 GHz). Decoders, classifiers, firmware. Attacks: buffer overflow, algorithm poisoning.</li>
        <li><span class="key">S3 Application</span> — Far-field RF (1 GHz+). Wireless, clinical software. Attacks: wireless interception, remote exploits.</li>
      </ul>
      <p>Why frequency? Just as <strong>every brain produces unique EEG patterns</strong>, every electronic device emits a unique electromagnetic fingerprint — from clock harmonics to analog imperfections. This is called <em>RF Fingerprinting</em> (>99% device ID accuracy). Each frequency regime has fundamentally different attack physics, so security must match the physics.</p>
    `,
    highlight: 'hourglass',
  },
  {
    title: 'The Equation',
    body: `
      <span class="eq">
        QI(b,t) = e<sup>-\u03A3(b,t)</sup><br><br>
        <span class="dim">where</span> \u03A3 = <span class="term">\u03A3<sub>c</sub></span> + <span class="term">\u03A3<sub>q</sub></span>
      </span>
      <p>This is a <strong>Boltzmann factor</strong> — the same equation from statistical physics that governs thermal equilibrium.</p>
      <p><span class="term">\u03A3</span> is the total <em>anomaly energy</em>. It has two parts:</p>
      <ul>
        <li><span class="key">\u03A3<sub>c</sub></span> — classical anomalies (phase noise, amplitude instability, timing entropy)</li>
        <li><span class="key">\u03A3<sub>q</sub></span> — quantum anomalies (indeterminacy, tunneling, entanglement)</li>
      </ul>
      <p>When \u03A3 is low, QI \u2192 1 (healthy). When \u03A3 is high, QI \u2192 0 (anomalous). The exponential decay means even small anomalies compound fast.</p>
    `,
    highlight: null,
  },
  {
    title: 'Four Panels',
    body: `
      <p>Each panel maps to a standard scientific visualization:</p>
      <ul>
        <li><span class="key">A. Energy Landscape</span> (left) — Particles sit in potential wells. Low = healthy. Attacks push them uphill. Width = the hourglass state space.</li>
        <li><span class="key">B. Spectrogram</span> (top-right) — Heatmap of QI over time for all 11 bands. Blue = safe, red = anomalous. This is how BCI researchers read neural data.</li>
        <li><span class="key">C. Phase Portrait</span> (bottom-center) — \u03A3<sub>c</sub> vs \u03A3<sub>q</sub> orbit. Tight = stable. Expanding = attack in progress.</li>
        <li><span class="key">D. QI Waveform</span> (bottom-right) — Live QI time series. Like an EEG oscilloscope with threshold lines at 0.6 and 0.3.</li>
      </ul>
      <p class="dim">Hover any band on the landscape to see its full per-term equation breakdown.</p>
    `,
    highlight: null,
  },
  {
    title: 'I\u2080 Detection & Blocking',
    body: `
      <p>I\u2080 is the <strong>security checkpoint</strong> — the narrowest point of the hourglass where neural signals cross into the synthetic domain.</p>
      <p>The detection system monitors QI(I\u2080) in real time:</p>
      <ul>
        <li><span style="color:#4c8">QI > 0.6</span> — Normal. Gate open. Signals pass freely.</li>
        <li><span style="color:#cc8">0.3 < QI < 0.6</span> — Warning. Anomaly detected. Signal attenuated.</li>
        <li><span style="color:#f55">QI < 0.3</span> — <strong>BLOCKED.</strong> Gate closes. Nothing passes through.</li>
      </ul>
      <p>Watch the glowing ring around I\u2080 and the gate bar below it. When it's red, signals bounce back — the synthetic side stays clean.</p>
      <p class="dim">Toggle the shield in the sidebar (top-right) to see what happens without protection.</p>
    `,
    highlight: 'i0',
  },
  {
    title: 'Try It',
    body: `
      <p>You're ready to explore. A few things to try:</p>
      <ul>
        <li><span class="key">Hover a band</span> — see per-term equation breakdown</li>
        <li><span class="key">Click a band</span> — select it for the phase portrait + waveform</li>
        <li><span class="key">Space</span> — fire a decoherence pulse (watch \u0393<sub>D</sub> spike)</li>
        <li><span class="key">Controls</span> (top-right) — weight sliders, attack scenarios, I\u2080 shield</li>
      </ul>
      <p>Try launching a <strong>Classical Injection</strong> attack from the sidebar and watch the I\u2080 gate respond. Then toggle the shield off to see the difference.</p>
      <p class="dim">Press <span class="key">?</span> anytime to reopen this guide.</p>
    `,
    highlight: null,
  },
];

const tourEl = document.getElementById('tour');
const tourScrim = document.getElementById('tour-scrim');
const tourBody = document.getElementById('tour-body');
const tourStepLabel = document.getElementById('tour-step');
const tourProgress = document.getElementById('tour-progress');
const tourBackBtn = document.getElementById('tour-back');
const tourNextBtn = document.getElementById('tour-next');
let tourStep = 0;

// Build progress dots
TOUR_STEPS.forEach(() => {
  const dot = document.createElement('span');
  dot.className = 'dot';
  tourProgress.appendChild(dot);
});

function tourRender() {
  const step = TOUR_STEPS[tourStep];
  tourStepLabel.textContent = `STEP ${tourStep + 1} / ${TOUR_STEPS.length}`;
  tourBody.innerHTML = `<h2>${step.title}</h2>${step.body}`;
  tourBackBtn.disabled = tourStep === 0;
  tourNextBtn.textContent = tourStep === TOUR_STEPS.length - 1 ? 'Start Exploring' : 'Next \u2192';

  // Update dots
  tourProgress.querySelectorAll('.dot').forEach((dot, i) => {
    dot.className = 'dot' + (i === tourStep ? ' active' : i < tourStep ? ' done' : '');
  });

  // Highlight logic
  tourHighlightBand = step.highlight === 'hourglass' ? 'hourglass' : step.highlight === 'i0' ? 'i0' : null;

  // Select I₀ band during I₀ step
  if (step.highlight === 'i0') selectedBand = 7;
}

let tourHighlightBand = null;

function tourNext() {
  if (tourStep < TOUR_STEPS.length - 1) { tourStep++; tourRender(); }
  else tourClose();
}
function tourBack() {
  if (tourStep > 0) { tourStep--; tourRender(); }
}
function tourClose() {
  tourEl.classList.add('hidden');
  tourScrim.classList.add('hidden');
  document.getElementById('tour-reopen').style.display = 'block';
  tourHighlightBand = null;
}
function tourOpen() {
  tourEl.classList.remove('hidden');
  tourScrim.classList.remove('hidden');
  document.getElementById('tour-reopen').style.display = 'none';
  tourRender();
}

tourNextBtn.addEventListener('click', tourNext);
tourBackBtn.addEventListener('click', tourBack);
document.getElementById('tour-skip').addEventListener('click', tourClose);
document.getElementById('tour-reopen').addEventListener('click', () => { tourStep = 0; tourOpen(); });

// Start the tour
tourRender();

// ── SIDEBAR ──

document.getElementById('toggle-sidebar').addEventListener('click', () => {
  document.getElementById('sidebar').classList.toggle('open');
});

// Weight sliders
document.querySelectorAll('#sidebar input[type=range][data-key]').forEach(el => {
  el.addEventListener('input', () => {
    const key = el.dataset.key;
    const val = parseFloat(el.value);
    if (key in w) w[key] = val;
    if (key in psi) psi[key] = val;
    el.nextElementSibling.textContent = val.toFixed(1);
  });
});

// Speed slider
document.getElementById('speed-slider').addEventListener('input', function() {
  speed = parseFloat(this.value);
  document.getElementById('speed-val').textContent = speed.toFixed(1);
});

// Buttons
document.getElementById('btn-tunnel').addEventListener('click', () => {
  tunnelingActive = !tunnelingActive;
  const btn = document.getElementById('btn-tunnel');
  btn.textContent = `Tunneling: ${tunnelingActive ? 'ON' : 'OFF'}`;
  btn.classList.toggle('active', tunnelingActive);
});
document.getElementById('btn-decohere').addEventListener('click', () => { decoherencePulse = true; pulseStart = time; });
document.getElementById('btn-info').addEventListener('click', () => { tourStep = 0; tourOpen(); });

// I₀ Shield controls
document.getElementById('btn-shield').addEventListener('click', () => {
  i0Shield = !i0Shield;
  const btn = document.getElementById('btn-shield');
  btn.textContent = `Shield: ${i0Shield ? 'ON' : 'OFF'}`;
  btn.classList.toggle('active', i0Shield);
});
document.getElementById('btn-shield-log').addEventListener('click', () => {
  logVisible = !logVisible;
  document.getElementById('i0-log').classList.toggle('visible', logVisible);
});
document.getElementById('threshold-slider').addEventListener('input', function() {
  i0BlockThreshold = parseFloat(this.value);
  i0WarnThreshold = Math.min(0.9, i0BlockThreshold + 0.3);
  document.getElementById('threshold-val').textContent = i0BlockThreshold.toFixed(2);
});

// Attack scenarios
document.getElementById('atk-classical').addEventListener('click', () => {
  attackBoost.sigma_phi = 0.5; attackBoost.sigma_gamma = 0.4;
});
document.getElementById('atk-quantum').addEventListener('click', () => {
  attackBoost.qi_boost = 0.5; attackBoost.qe_suppress = 0.3;
});
document.getElementById('atk-tunnel').addEventListener('click', () => {
  attackBoost.qt_boost = 0.4;
});
document.getElementById('atk-reset').addEventListener('click', () => {
  attackBoost.sigma_phi = 0; attackBoost.sigma_gamma = 0;
  attackBoost.qi_boost = 0; attackBoost.qe_suppress = 0; attackBoost.qt_boost = 0;
  Object.assign(w, { w1: 1, w2: 1, w3: 1, w4: 1 });
  Object.assign(psi, { p1: 1, p2: 1, p3: 1 });
  i0GateAnim = 0;
  document.querySelectorAll('#sidebar input[type=range][data-key]').forEach(el => {
    el.value = 1; el.nextElementSibling.textContent = '1.0';
  });
});
</script>
</body>
</html>
